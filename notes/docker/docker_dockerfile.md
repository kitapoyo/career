# Dockerfile
1. [Dockerfile とは](#anchor1)
   - Linux Image
   - Dockerfile の処理
2. [イメージのビルド ( image build )](#anchor2)
3. [不要ファイルの除外 ( .dockerignore )](#anchor3)
4. [ステージングビルド](#anchor4)
   - コンパイラ処理
   - バイナリアプリコンテナ ( Scratch )

<a id="anchor1"></a>

## 1. Dockerfile とは
 - Docker Image を作成するための設計書で、**ビルド ( build )** することでイメージを作成します。<br>イメージを作成する際は、Dockerfile と同じディレクトリに必要なファイルなどを詰め込んでビルドします。
 - ファイル名は大文字小文字を区別し、拡張子は無しで **Dockerfile** とします。
 - Dockerfile は１行ずつ実行する処理を記述し、上から下にビルド処理を行います。

### Linux Image

|イメージ|サイズ|説明|
|----|----|---|
|ubuntu:18.04|64.2MB||
|alpine:3.10.3|5.55MB|現代的な Linux 操作が可能です。|
|busybox:1.31.1|1.22MB|サイズは小さいですが機能が少ないため利便性が落ちます。|

### Dockerfile の処理

|処理|説明|
|----|----|
|FROM < ベースイメージ名 > { as < 名前 > }|利用するベースイメージを宣言します。 ( 複数宣言できます )<br>` as ` を使用することでイメージに名前を与えることができます。|
|LABEL < 名前 >|イメージに追加する表示情報を宣言します。( 名前 , バージョン番号など )|
|RUN < コマンド > { && < コマンド２ > } |イメージをビルドする際に実行したいコマンドを宣言します。<br>バックスラッシュ ( \ ) でコマンドの改行ができます。<br>` && ` で前のコマンドが成功したら次のコマンドを実行することができます。 |
|CMD < コマンド >|コンテナを起動する際に実行するデフォルトのコマンドを宣言します。<br>角カッコ ( [ ] ) 内にコマンドとオプションをカンマ ( , ) 区切りで並べる記法が推奨されています。|
|COPY { --from=< イメージ名 > } < コピー元 > < コピー先 >|イメージにコピーするファイルやディレクトリを宣言します。<br>**コピー元は Dockerfile から相対パスで指定します。**<br>**コピー先は絶対パスで指定します。**<br>` --from= ` を使用することでコンテナイメージからコピーすることができます。|
|EXPOSE < ポート番号 >|外部に公開するポートを宣言します。<br>` run -p ` オプションを指定しないと外部からコンテナに接続はできません。|
|ENV < 環境変数名 > < 値 >|環境変数のデフォルト値を宣言します。<br>` docker container run ` コマンドのオプションで上書きが可能です。|
|ENTRYPOINT < コマンド >|CMD と同様にコンテナを起動する際に実行するコマンドを宣言します。<br>` ENTRYPOINT ["nginx"] ` のように設定すると<br> ` run ` 時に与えられるコマンドは ` nginx ` コマンドのオプションとして扱われます。|
|VOLUME < マウント領域 >|` run ` コマンドで指定しなくても、指定した領域にボリュームを新規作成する場合に利用します。|
|USER < ユーザー名 >|コマンドを実行する際のユーザーを宣言します。<br>root ユーザーを指定することが多いです。|
|WORKDIR < ディレクトリ > |コマンドを実行する際の作業ディレクトリを宣言します。<br>宣言したディレクトリが存在しなければ作成されます。<br>RUN 処理で ` cd ` コマンドで移動した状態は、**次の RUN 処理には反映されません。**|
|STOPSIGNAL < シグナル >|コンテナ停止時のシグナルを宣言します。デフォルトは ` SIGTERM ` です。|

<a id="anchor2"></a>

## 2. イメージのビルド ( image build )
 - ビルドは Dockerfile の処理を上から順に実行し、途中でエラーが発生すると残りの処理はスキップされて失敗になります。
 - ベースイメージが同じであれば、前回の処理結果をそのまま利用する ( Using cache ) ことができるのでビルド時間を短縮できます。
 - ビルド成功時は ` Successfully built < イメージ名 > ` と表示されます。・

   ```:コマンド
   docker image build -t ( < 作成するイメージ名 > | < 作成するイメージ名:タグ名 > ) < Dockerfile のパス >
   ```

   |オプション|説明|
   |----|----|
   |-t|イメージ名だけでなくタグ名を ` 作成するイメージ名:タグ名 ` と指定できます。<br>タグ名がない場合はデフォトの ` latest ` になります。|
   |-f|使用する Dcokerfile を名前付きで宣言します。<br>` Dockerfile.alt ` のように標準とは異なる Dockerfile 名を使用する場合に利用します。|
   |--no-cache|Using cache を利用しない場合に利用します。<br>|

<a id="anchor3"></a>

## 3. 不要ファイルの除外 ( .dockerignore )
 - ` .dockerignore ` ファイルを Dockerfile と同じディレクトリに配置します。<br>` COPY ` などの対象から指定した形式のファイルは除外されます。
 - ２つのアスタリスクとスラッシュ ( \*\*\/ ) に続けてファイル名やディレクトリ名を記述すると階層構造を無視して除外されます。

    ```:記述例
    **/__pycache__
    ```

<a id="anchor4"></a>

## 4. ステージングビルド
 - イメージ作成に必要な作業を別のコンテナで実行することです。<br>作業用のコンテナで作成したイメージから本番用のイメージで使うデータを使用することができ、**イメージサイズを縮小させることができます。**

### コンパイラ処理
 - C 言語や Java 言語は、**プログラムを実行する前にコンパイル処理 ( ソースコードをバイナリ形式に変換 ) を行います。**
 - コンパイラが大きい場合、コンテナイメージの容量が大きくなってしまいます。
 - Docker では以下の方法で大きなコンパイラを持たない軽量なイメージを作成することができます。
1. ソースコードをコンパイルしてバイナリファイルを生成する１つ目のコンテナイメージを作成する。
2. 実行環境の２つ目のコンテナイメージに、１つ目のイメージから取得して実行する。

### バイナリアプリコンテナ ( Scratch )
 - **Scratch** と呼ばれる OS を搭載しないイメージにバイナリファイルを載せて起動することができます。
 - 超軽量なイメージが作成できますが、Linux 機能は使用できません。
